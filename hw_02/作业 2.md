> - #### 作业2
>
>   ###### MATLAB code：
>
>   ```matlab
>   size_map = size(map,1); 
>   %size_map:起点+终点+障碍物的总数
>   %map:第一个是起点，最后一个是终点，其余是障碍物
>   ```
>
>   ```matlab
>   set(gcf, 'Renderer', 'painters'); %渲染器
>   ```
>
>   >**The Default Renderer for MATLAB**
>   >
>   >By default, MATLAB automatically selects the best rendering method, based on the attributes of the figure (its complexity and the settings of various Handle Graphics properties) and in some cases, the printer driver or file format used.
>   >
>   >In general, MATLAB uses
>   >
>   >- Painter's for line plots, area plots (bar graphs, histograms, etc.), and simple surface plots
>   >- Z-buffer when the computer screen is not truecolor or when the `opengl` function was called with `selection_mode` set to `neverselect`
>   >- OpenGL for complex surface plots using interpolated shading and any figure using lighting
>
>   ![image-20200717223222021](image/image-20200717223222021.png)
>
>   ```matlab
>   function path = A_star_search(map,MAX_X,MAX_Y)
>   %%
>   %This part is about map/obstacle/and other settings
>       %pre-process the grid map, add offset
>       size_map = size(map,1);
>       %size_map:起点+终点+障碍物的总数
>       %map:第一个是起点，最后一个是终点，其余是障碍物
>       Y_offset = 0;
>       X_offset = 0;
>       
>       %Define the 2D grid map array: MAP.
>       %MAP中Obstacle=-1, Target = 0, Start=1,空白=2
>       MAP=2*(ones(MAX_X,MAX_Y));
>       
>       %Initialize MAP with location of the target=0
>       xval=floor(map(size_map, 1)) + X_offset;
>       yval=floor(map(size_map, 2)) + Y_offset;
>       xTarget=xval;
>       yTarget=yval;
>       MAP(xval,yval)=0;
>       
>       %Initialize MAP with location of the obstacle=-1
>       for i = 2: size_map-1 %number of obstacle
>           xval=floor(map(i, 1)) + X_offset;
>           yval=floor(map(i, 2)) + Y_offset;
>           MAP(xval,yval)=-1;
>       end 
>       
>       %Initialize MAP with location of the start point=1
>       xval=floor(map(1, 1)) + X_offset;
>       yval=floor(map(1, 2)) + Y_offset;
>       xStart=xval;
>       yStart=yval;
>       MAP(xval,yval)=1;
>   
>       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>       %LISTS USED FOR ALGORITHM
>       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>       %OPEN LIST STRUCTURE
>       %--------------------------------------------------------------------------
>       %IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
>       %--------------------------------------------------------------------------
>       OPEN=[];
>       %CLOSED LIST STRUCTURE
>       %--------------
>       %X val | Y val |
>       %--------------
>       % CLOSED=zeros(MAX_VAL,2);
>       CLOSED=[];
>   
>       %Put all obstacles on the Closed list
>       k=1;%Dummy counter
>       for i=1:MAX_X
>           for j=1:MAX_Y
>               if(MAP(i,j) == -1)
>                   CLOSED(k,1)=i;
>                   CLOSED(k,2)=j;
>                   k=k+1;
>               end
>           end
>       end
>       CLOSED_COUNT=size(CLOSED,1);
>       %set the starting node as the first node
>       xNode=xval;
>       yNode=yval;
>       OPEN_COUNT=1;
>       hn=distance(xNode,yNode,xTarget,yTarget);
>       gn=0;
>       fn=hn+gn; 
>       OPEN(OPEN_COUNT,:)=insert_open(xNode,yNode,xNode,yNode,hn,gn,fn); %!!!
>       OPEN(OPEN_COUNT,1)=0;%set first node as '0'means checked/visited
>       CLOSED_COUNT=CLOSED_COUNT+1;
>       CLOSED(CLOSED_COUNT,1)=xNode; %first node is saved in CLOSED list
>       CLOSED(CLOSED_COUNT,2)=yNode;
>       NoPath=1;
>       FinishSearch=0;
>   
>   %%
>   %This part is your homework
>   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>   % START ALGORITHM
>   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>       while(~FinishSearch) %you have to dicide the Conditions for while loop exit 
>           if(xNode == xTarget && yNode == yTarget)  %target node found, break loop
>               break           
>           end
>           exp_array = expand_array(xNode,yNode,gn,xTarget,yTarget,CLOSED,MAX_X,MAX_Y);
>           % expand_array:|X val |Y val |h(n) |g(n)|f(n)|
>           size_expand = size(exp_array,1);
>           for i = 1:1:size_expand
>               temp_x=exp_array(i,1);
>               temp_y=exp_array(i,2);
>               temp_h=exp_array(i,3);
>               temp_g=exp_array(i,4);
>               temp_f=exp_array(i,5);
>           
>               %查找当前要扩展的节点是否已经在OPEN list中,返回该节点的索引
>               n_index = node_index(OPEN,temp_x,temp_y);
>              
>               if(n_index == OPEN_COUNT+1) %扩展的节点不在OPEN list中
>                   OPEN_COUNT=OPEN_COUNT+1;
>                   OPEN(OPEN_COUNT,:)=insert_open(temp_x,temp_y,xNode,yNode,temp_h,temp_g,temp_f);
>               else  %扩展的节点已经在OPEN list中，重新计算g，f值，h（不变），还有parent node
>                   OPEN_g=OPEN(n_index,7);
>                   
>                   if(OPEN_g > temp_g)
>                       OPEN(n_index,4)=xNode;
>                       OPEN(n_index,5)=yNode;
>                       OPEN(n_index,6)=temp_h;  %h相同
>                       OPEN(n_index,7)=temp_g;
>                       OPEN(n_index,8)=temp_f;
>                       
>                   end 
>               end
>           end    
>       
>           i_min=min_fn(OPEN,OPEN_COUNT,xTarget,yTarget);%弹出现在path cost最小的node
>           OPEN(i_min,1)=0; %marked as visted
>           xNode=OPEN(i_min,2);%move to this node
>           yNode=OPEN(i_min,3);
>           gn=OPEN(i_min,7); %7：g(n)path cost;8：f(n)total cost!!!
>           
>           %弹出的node存入CLOSED list
>           CLOSED_COUNT=CLOSED_COUNT+1;
>           CLOSED(CLOSED_COUNT,1)=xNode;
>           CLOSED(CLOSED_COUNT,2)=yNode;
>        
>       end %End of While Loop
>       
>       %Once algorithm has run The optimal path is generated by starting of at the
>       %last node(if it is the target node) and then identifying its parent node
>       %until it reaches the start node.This is the optimal path
>       %optimal path after A_star search
>    
>       path=[];
>       count=1;
>       last_x=xNode; %存入终点
>       last_y=yNode;
>       %从终点开始，寻找当前节点的parent node，直到找到起点，形成path
>       while(last_x ~= xStart || last_y ~= yStart)
>           path(count,:)=[last_x,last_y];  %将当前点存入path中
>           count=count+1;
>           current_index=node_index(OPEN,last_x,last_y);
>           last_x=OPEN(current_index,4);%找到当前节点的parent坐标
>           last_y=OPEN(current_index,5);
>       end
>       path(count,:)=[xStart, yStart];
>       
>        
>   end
>   
>   ```
>
>   
>
>   ###### MATLAB 指令
>
>   - index从1开始，“:” 中不去头不去尾
>
>     ```matlab
>     i= 2:3
>     ```
>
>     i = [2, 3]
>
>   - OPEN LIST STRUCTURE
>
>     |1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
>
>     1:没查， 0:已查
>
>   - tap键works
>
>   - loop没有冒号，条件在（）中
>
>   - command + T：取消comment  
>
>     command + /： comment  
>
>   - 
>
>     ```matlab
>     set(gcf,'position',[x0,y0,width,height])
>     ```
>
>     By default, the position is in pixels.
>
>   ###### ROS code
>
>   ###### ROS 指令