# 作业2

## MATLAB code：

```matlab
size_map = size(map,1); 
%size_map:起点+终点+障碍物的总数
%map:第一个是起点，最后一个是终点，其余是障碍物
```

```matlab
set(gcf, 'Renderer', 'painters'); %渲染器
```

>**The Default Renderer for MATLAB**
>
>By default, MATLAB automatically selects the best rendering method, based on the attributes of the figure (its complexity and the settings of various Handle Graphics properties) and in some cases, the printer driver or file format used.
>
>In general, MATLAB uses
>
>- Painter's for line plots, area plots (bar graphs, histograms, etc.), and simple surface plots
>- Z-buffer when the computer screen is not truecolor or when the `opengl` function was called with `selection_mode` set to `neverselect`
>- OpenGL for complex surface plots using interpolated shading and any figure using lighting

![image-20200717223222021](image/image-20200717223222021.png)

```matlab
function path = A_star_search(map,MAX_X,MAX_Y)
%%
%This part is about map/obstacle/and other settings
    %pre-process the grid map, add offset
    size_map = size(map,1);
    %size_map:起点+终点+障碍物的总数
    %map:第一个是起点，最后一个是终点，其余是障碍物
    Y_offset = 0;
    X_offset = 0;
    
    %Define the 2D grid map array: MAP.
    %MAP中Obstacle=-1, Target = 0, Start=1,空白=2
    MAP=2*(ones(MAX_X,MAX_Y));
    
    %Initialize MAP with location of the target=0
    xval=floor(map(size_map, 1)) + X_offset;
    yval=floor(map(size_map, 2)) + Y_offset;
    xTarget=xval;
    yTarget=yval;
    MAP(xval,yval)=0;
    
    %Initialize MAP with location of the obstacle=-1
    for i = 2: size_map-1 %number of obstacle
        xval=floor(map(i, 1)) + X_offset;
        yval=floor(map(i, 2)) + Y_offset;
        MAP(xval,yval)=-1;
    end 
    
    %Initialize MAP with location of the start point=1
    xval=floor(map(1, 1)) + X_offset;
    yval=floor(map(1, 2)) + Y_offset;
    xStart=xval;
    yStart=yval;
    MAP(xval,yval)=1;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %LISTS USED FOR ALGORITHM
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %OPEN LIST STRUCTURE
    %--------------------------------------------------------------------------
    %IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
    %--------------------------------------------------------------------------
    OPEN=[];
    %CLOSED LIST STRUCTURE
    %--------------
    %X val | Y val |
    %--------------
    % CLOSED=zeros(MAX_VAL,2);
    CLOSED=[];

    %Put all obstacles on the Closed list
    k=1;%Dummy counter
    for i=1:MAX_X
        for j=1:MAX_Y
            if(MAP(i,j) == -1)
                CLOSED(k,1)=i;
                CLOSED(k,2)=j;
                k=k+1;
            end
        end
    end
    CLOSED_COUNT=size(CLOSED,1);
    %set the starting node as the first node
    xNode=xval;
    yNode=yval;
    OPEN_COUNT=1;
    hn=distance(xNode,yNode,xTarget,yTarget);
    gn=0;
    fn=hn+gn; 
    OPEN(OPEN_COUNT,:)=insert_open(xNode,yNode,xNode,yNode,hn,gn,fn); %!!!
    OPEN(OPEN_COUNT,1)=0;%set first node as '0'means checked/visited
    CLOSED_COUNT=CLOSED_COUNT+1;
    CLOSED(CLOSED_COUNT,1)=xNode; %first node is saved in CLOSED list
    CLOSED(CLOSED_COUNT,2)=yNode;
    NoPath=1;
    FinishSearch=0;

%%
%This part is your homework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% START ALGORITHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    while(~FinishSearch) %you have to dicide the Conditions for while loop exit 
        if(xNode == xTarget && yNode == yTarget)  %target node found, break loop
            break           
        end
        exp_array = expand_array(xNode,yNode,gn,xTarget,yTarget,CLOSED,MAX_X,MAX_Y);
        % expand_array:|X val |Y val |h(n) |g(n)|f(n)|
        size_expand = size(exp_array,1);
        for i = 1:1:size_expand
            temp_x=exp_array(i,1);
            temp_y=exp_array(i,2);
            temp_h=exp_array(i,3);
            temp_g=exp_array(i,4);
            temp_f=exp_array(i,5);
        
            %查找当前要扩展的节点是否已经在OPEN list中,返回该节点的索引
            n_index = node_index(OPEN,temp_x,temp_y);
           
            if(n_index == OPEN_COUNT+1) %扩展的节点不在OPEN list中
                OPEN_COUNT=OPEN_COUNT+1;
                OPEN(OPEN_COUNT,:)=insert_open(temp_x,temp_y,xNode,yNode,temp_h,temp_g,temp_f);
            else  %扩展的节点已经在OPEN list中，重新计算g，f值，h（不变），还有parent node
                OPEN_g=OPEN(n_index,7);
                
                if(OPEN_g > temp_g)
                    OPEN(n_index,4)=xNode;
                    OPEN(n_index,5)=yNode;
                    OPEN(n_index,6)=temp_h;  %h相同
                    OPEN(n_index,7)=temp_g;
                    OPEN(n_index,8)=temp_f;
                    
                end 
            end
        end    
    
        i_min=min_fn(OPEN,OPEN_COUNT,xTarget,yTarget);%弹出现在path cost最小的node
        OPEN(i_min,1)=0; %marked as visted
        xNode=OPEN(i_min,2);%move to this node
        yNode=OPEN(i_min,3);
        gn=OPEN(i_min,7); %7：g(n)path cost;8：f(n)total cost!!!
        
        %弹出的node存入CLOSED list
        CLOSED_COUNT=CLOSED_COUNT+1;
        CLOSED(CLOSED_COUNT,1)=xNode;
        CLOSED(CLOSED_COUNT,2)=yNode;
     
    end %End of While Loop
    
    %Once algorithm has run The optimal path is generated by starting of at the
    %last node(if it is the target node) and then identifying its parent node
    %until it reaches the start node.This is the optimal path
    %optimal path after A_star search
 
    path=[];
    count=1;
    last_x=xNode; %存入终点
    last_y=yNode;
    %从终点开始，寻找当前节点的parent node，直到找到起点，形成path
    while(last_x ~= xStart || last_y ~= yStart)
        path(count,:)=[last_x,last_y];  %将当前点存入path中
        count=count+1;
        current_index=node_index(OPEN,last_x,last_y);
        last_x=OPEN(current_index,4);%找到当前节点的parent坐标
        last_y=OPEN(current_index,5);
    end
    path(count,:)=[xStart, yStart];
    
     
end

```



#### MATLAB 指令s

- index从1开始，“:” 中不去头不去尾

  ```matlab
  i= 2:3
  ```

  i = [2, 3]

- OPEN LIST STRUCTURE

  |1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|

  1:没查， 0:已查

- tap键works

- loop没有冒号，条件在（）中

- command + T：取消comment  

  command + /： comment  

- 

  ```matlab
  set(gcf,'position',[x0,y0,width,height])
  ```

  By default, the position is in pixels.

## 

## ROS code

#### .launch file

```
<arg name="map_size_x" default="10.0"/>
<arg name="map_size_y" default="10.0"/>
<arg name="map_size_z" default=" 1.0"/>
```

生成obstacle map：第一层0，共5层（0-4）表示1m

```
<arg name="map_size_x" default="10.0"/>
<arg name="map_size_y" default="10.0"/>
<arg name="map_size_z" default=" 2.0"/>
```

生成obstacle map：第一层0，共10层（0-9）表示2m

```
rosparam get /[tap]
```

查看parameter

```
---roslaunch/XML/node attributes---
在：  <node pkg="grid_path_searcher" type="demo_node" name="demo_node" output="screen" required = "true">中
required = "true"
```

If node dies, kill entire roslaunch 

#### commend line 

```shell
roscore      //第一个commend window

source devel/setup.bash      //第二个commend window

 roslaunch grid_path_searcher demo.launch
```

![A*](image/A*.png)

#### 颜色：

左侧选项选择background，obstacle颜色，path颜色coding path还是不能改变

#### 固定地图

#### heuristic function：

##### Diagonal：

>diag = min{dx, dy, dz}
>
>​    if(diag == dx)
>
>​      h = **sqrt**(3.0)*diag+**sqrt**(2.0)***min**((dy-diag),(dz-diag))+**abs**(dy-diag)
>
>​    if(diag == dy)
>
>​      h = **sqrt**(3.0)*diag+**sqrt**(2.0)***min**((dx-diag),(dz-diag))+**abs**(dz-diag)
>
>​    if(diag == dz)
>
>​      h = **sqrt**(3.0)*diag+**sqrt**(2.0)***min**((dx-diag),(dy-diag))+**abs**(dx-diag)

##### Manhattan:

> ​    dx = abs(node.x - goal.x)
>
> ​    dy = abs(node.y - goal.y)
>
> ​	dz = abs(node.z - goal.z)
>
> ​     return D \* (dx + dy + dz)

##### Euclidean:

> dx = abs(node.x - goal.x)
>
>​    dy = abs(node.y - goal.y)
>
>​	dz = abs(node.z - goal.z)
>
>**sqrt**(dx * dx + dy * dy + dz * dz)

为什么会出现Manhattan启发函数效率最高的情形，甚至比Diagonal还要快：

启发式函数最优性条件：h(t) <h*(t),使用Manhattan不满足以上条件。在牺牲最优性的前提下Manhattan会扩展更少的点，带来更快的效率，但不具备最优性，所以不采用其作为启发式函数